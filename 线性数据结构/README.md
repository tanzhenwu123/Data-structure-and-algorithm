### 什么是线型数据结构
```
线型数据结构强调存储与顺序,是一种最基本的数据结构
```

#### 数组
```
数组的扩容过程是消耗性能的，在使用数组的过程中应该先声明数组的长度，以节省性能
数组在扩容时操作系统会开辟一个新的空间，重新划分该数组的容量
划分完空间后，该数组前半段为原先的数组内容
后半段则为新的空间
并且在新增空间的第一个索引开始添加新的数据

所以在设计数组的时候，开始就要设想好一个数组的大概空间

特性:
1.存储在物理空间上并且时连续的
2.底层的数组长度时不可变的(js里的数组长度为什么可变，按照其他的语言来讲，数组的长度就是固定的，之所以在js中可变是因为在浏览器中，v8引擎对数组进行了优化)
3.数组的变量，指向了数组第一个元素的位置,在js索引器里，方括号代表的是存储地址的偏移

优点:
1.查询性能好,直接通过索引器可以获得到该数据的位置(在操作系统里:通过偏移，查询数据性能比较好.)

缺点:
1.空间必须是连续的，假如数组比较大，容易存储不下；当系统的空间碎片比较多的时候，容易存不下

(什么是空间碎片:
每一个程序在运行的时候都会声明一个变量，而变量在操作系统上会占据一定的内存空间。当程序结束的时候,程序当前所在的位置会空出来,这种小的空闲空间称之为空间碎片)

2.数组的长度是固定的，所以数组的内容难以被添加和删除。
(一但删除一个数据，将会把删除下标后的数据进行逐移，消耗的性能会很大)
```

#### 链表(常见数据结构)
```
链表形式 [存储数据,引用对象]


a[1,b] -> b[2,引用对象]

链表的特性:(单向,只知道自己指向谁，不知道谁指向自己)
1. 在空间上，不是连续的，在空间上是存在跳跃的
2.没存放一个值，就需要多开销一个引用空间
3.链表默认为单链表
4.每个节点(都认为他是根节点)都是链表的起始点

优点：
1.只要空间足够大，就可以储存，无需担心空间碎片问题

例子:
3 -> 6 -> 4
从三到四之间存储一个6
const fore = {
    value:4,
    next:null
}

const six = {
    value:6,
    next:fore
}

const three = {
    value:3,
    next:six
}

2.链表的添加和删除都十分方便

缺点:
1.查询速度比较慢(查询某个位置)
2.链表每一个节点需要创建一个next引用，比较浪费空间(但是一个链表里如果存储的数据越多，这个影响就越少)
```

##### 链表的逆置
```
每个链表的节点都认为它是链表的起始点(因为链表的结构导致节点只知道自己指向谁而不知道谁指向自己)
逆置链表的思维:
使用递归，递归整个链表数据结构，为了整个函数的严谨，首先得找到递归函数的出口
1.如果我递归的函数，传的唯一参数的指向对象的指向对象为空对象(意思就是传的参是倒数第二个节点，他的指向对象是最后一个节点，而最后一个节点的指向为null)
2.那么最后一个节点的指向为倒数第二个指向，倒数第二个节点的指向为null(完成了初步递归的出口逻辑)
3.该函数出口返回最后一个节点

如果不是倒数第二个的话（别杠最后一个，最后一个节点逆置还是指向next，不如想想链表的指向规则）
1.首先递归函数需要先声明一个变量来调用该递归函数,先不开始递归(传递参数的指向对象)
2.这边假设需要逆置的节点是链表的第一个节点
3.那么该节点的指向对象的指向对象(也就是第二个节点的指向对象为第一个节点，初步的逆置)
4.第一个节点的指向为null
5.完成了上面的初步逆置后,再返回开始声明的递归变量，开始递归
```

##### 冒泡排序
```
排序的本质是:比较和交换
两数之间进行比较,冒泡排序每次运行时会将需要交换的两个数据进行交换

冒泡排序思维:
1.比较两数是否需要交换
2.交换两数
3.包括两层循环，第一次循环循环整个数组的长度，第二次循环会对两数之间进行比较，由于每次比较都会将两数对比并且把最大的树交换至数组末尾
所以第二层循环每循环一次都减少第一层循环相应的次数来增强性能，直至排序结束
```

##### 选择排序
```
选择排序思维：
1.比较
2.交换
3.两层循环，声明一个临时变量，代表着当前比较数据最大的数据的下标
4.第二层循环进行比较，得出需要交换的数据的下标
5.将最大的数据排至数组末尾
```

> 注意: 冒泡排序和选择排序的不同
```
冒泡排序每次排序都会将需要交换的数据进行交换，而选择排序每循环一次都会将最大的数据排到数组的末尾
```

##### 快速排序
```
快速排序思路:
1.取一个需要比较的数据
2.制定交换规则进行交换
```